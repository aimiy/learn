<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>二叉树</title>
</head>
<script>

    function printTree(root) {

    }
</script>

<body>
    <h1>104树的高度</h1>20200229
    <!-- <script>
        let tree = {
            val: 3,
            left: {
                val: 9,
                left: null,
                right: null
            },
            right: {
                val: 20,
                left: {
                    val: 15,
                    left: null,
                    right: null
                },
                right: {
                    val: 7,
                    left: null,
                    right: null
                }
            }
        }
        // 递归
        // var maxDepth = function (root) {
        //     if (root == null) return 0;
        //     return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
        // };
        // 迭代
        var maxDepth = function (root) {
            let depth = 0;
            let stack = [];
            if (root !== null) {
                root.current_dep = 1;
            }
            stack.push(root);
            while (stack.length !== 0) {
                console.log(JSON.parse(JSON.stringify(stack)));
                let node = stack.pop();
                if (node !== null) {
                    depth = Math.max(depth,node.current_dep);
                    if (node.right) {
                        node.right.current_dep = node.current_dep+1;
                        stack.push(node.right)
                    }
                    if (node.left) {
                        node.left.current_dep = node.current_dep+1;
                        stack.push(node.left)
                    }
                }
            }
            return depth;
        };
        console.log(maxDepth(tree))
    </script> -->
    <h1>110平衡二叉树</h1>20200301
    <!-- <script>
        let tree = {
            val: 3,
            left: {
                val: 9,
                left: {
                    val:12,
                    left:{
                        val:23,
                        left:null,
                        right:null
                    },
                    right:null
                },
                right: null
            },
            right: {
                val: 20,
                left: {
                    val: 15,
                    left: null,
                    right: null
                },
                right: {
                    val: 7,
                    left: {
                        val:3,
                        left:null,
                        right:null
                    },
                    right: null
                }
            }
        }
        // 从上到下的递归暴力，每一个节点的高度都计算了
        // var isBalanced = function (root) {
        //     if(root ===null){
        //         return true;
        //     }
        //     if(Math.abs(height(root.left)-height(root.right))>1){
        //         return false;
        //     }
        //     return isBalanced(root.left) && isBalanced(root.right)
        // };
        // function height(node) {
        //     console.log(node)
        //     if (node === null) return 0;
        //     return Math.max(height(node.left), height(node.right)) + 1;
        // }
        // 从下到上的递归，多加了判断，假如子节点不平衡，直接得出父节点不平衡，不用再计算祖宗的其他节点
        // var isBalanced = function(root){
        //     return depth(root) !=-1;
        // }
        // function depth(node){
        //     console.log(node)
        //     if(node === null)
        //     return 0;
        //     let left = depth(node.left);
        //     if(left ===-1) 
        //     return -1;
        //     let right = depth(node.right);
        //     if(right ===-1)
        //     return -1;
        //     return Math.abs(left - right) < 2 ? Math.max(left, right) + 1 : -1;
        // }
        // console.log(isBalanced(tree))
    </script> -->
    <h1>543二叉树的直径</h1>20200301
    <!-- <script>
        let tree = {
            val: 3,
            left: {
                val: 9,
                left: {
                    val: 12,
                    left: {
                        val: 23,
                        left: null,
                        right: null
                    },
                    right: null
                },
                right: null
            },
            right: {
                val: 20,
                left: {
                    val: 15,
                    left: null,
                    right: null
                },
                right: {
                    val: 7,
                    left: {
                        val: 3,
                        left: null,
                        right: null
                    },
                    right: null
                }
            }
        }
        // 递归中的递归，高度计算过于冗余，本身计算高度就是暴力计算，每一个节点都到达过，所以直接在暴力计算高度函数中计算各节点路径，统计出最大路径
        // 简约
        let largestLength;
        var diameterOfBinaryTree = function (root) {
            largestLength = 1;
            height(root)
            return largestLength - 1;
        };
        function height(node) {
            if (node == null) {
                return 0
            }
            let L = height(node.left);
            let R = height(node.right);
            largestLength = Math.max(largestLength, L + R + 1)
            return Math.max(L, R) + 1;
        }
        console.log(diameterOfBinaryTree(tree));
    </script> -->
    <h1>226翻转二叉树</h1>20200302
    <!-- <script>
        let tree = {
            val: 3,
            left: {
                val: 9,
                left: {
                    val: 12,
                    left: {
                        val: 23,
                        left: null,
                        right: null
                    },
                    right: null
                },
                right: null
            },
            right: {
                val: 20,
                left: {
                    val: 15,
                    left: null,
                    right: null
                },
                right: {
                    val: 7,
                    left: {
                        val: 3,
                        left: null,
                        right: null
                    },
                    right: null
                }
            }
        }
        var invertTree = function (root) {
            if(root == null){
                return null;
            }
            console.log(root)
            let left = invertTree(root.left);
            let right = invertTree(root.right);
            root.right = left;
            root.left = right;
            return root;
        };
        console.log(invertTree(tree))
    </script> -->
    <h1>617合并二叉树</h1>20200302
    <!-- <script>
        let tree1 = {
            val: 1,
            left: {
                val: 3,
                left: {
                    val: 5
                }
            },
            right: {
                val: 2
            }
        }
        let tree2 = {
            val: 2,
            left: {
                val: 1,
                right: {
                    val: 4
                }
            },
            right: {
                val: 3,
                right: {
                    val: 7
                }
            }
        }

        var mergeTrees = function (t1, t2) {
            if (t1 == null && t2 == null) {
                return null;
            } else if (t1 == null) {
                return t2;
            } else if (t2 == null) {
                return t1;
            } else {
                t1.val += t2.val;
                t1.left = mergeTrees(t1.left, t2.left);
                t1.right = mergeTrees(t1.right, t2.right);
                return t1;
            }
        };
        console.log(mergeTrees(tree1, tree2))
    </script> -->
    <h1>112路径总和</h1>20200303
    <!-- <script>
        let tree = {
            val: 5,
            left: {
                val: 4,
                left: {
                    val: 11,
                    left: {
                        val: 7
                    },
                    right: {
                        val: 2
                    }
                },
            },
            right: {
                val: 8,
                left: {
                    val: 13
                },
                right: {
                    val: 4,
                    right: {
                        val: 1
                    }
                }
            }
        }
        // let tree = null;
        var hasPathSum = function (root, sum) {
            console.log(root, sum)
            if (root == null) {
                return false;
            }
            sum -= root.val;
            if(root.left == null && root.right == null){
                if (sum === 0) {
                    return true;
                }
                return false;
            }
            return hasPathSum(root.left, sum) || hasPathSum(root.right, sum)
        };
        console.log(hasPathSum(tree, 22))
    </script> -->
    <h1>437路径总和 III</h1>0303
    <!-- <script>
        // let tree = {
        //     val: 10,
        //     left: {
        //         val: 5,
        //         left: {
        //             val: 3,
        //             left: {
        //                 val: 3
        //             },
        //             right: {
        //                 val: -2
        //             }
        //         },
        //         right: {
        //             val: 2,
        //             right: {
        //                 val: 1
        //             }
        //         }
        //     },
        //     right: {
        //         val: -3,
        //         right: {
        //             val: 11
        //         }
        //     }
        // };
        let tree = {
            val:1
        }
        // 用到了深拷贝，性能太差
        // var pathSum = function (root, sum) {
        //     return recursionPathSum(root,[0],sum);
        // };
        // function recursionPathSum(node, prefixSumArr, target){
        //     if(node == null){
        //         return 0;
        //     }
        //     let res = 0;
        //     let arr = JSON.parse(JSON.stringify(prefixSumArr));
        //     let currSum = arr[arr.length-1];
        //     arr.push(currSum +=node.val);
        //     arr.forEach((element,key) => {
        //         if(element === currSum-target && key !==arr.length-1){
        //             res++;
        //         }
        //     });
        //     console.log(arr,res)
        //     res += recursionPathSum(node.left,arr,target);
        //     res += recursionPathSum(node.right,arr,target);
        //     return res;
        // }

        // 改进，上一个方法深拷贝是每一个节点都有自己的数组，这个方法公用一个数组，但记录了层次，不再push，是覆盖当前层次节点的值。因此不再暴力遍历，因为会有多余的值，只遍历当前层次p之前的数组
        // var pathSum = function (root, sum) {
        //     return recursionPathSum(root, [0], sum, 0);
        // };
        // function recursionPathSum(node, arr, target, p) {
        //     if (node == null) {
        //         return 0;
        //     }
        //     let tmp = node.val;
        //     let res = node.val === target ? 1 : 0;
        //     for (let i = p - 1; i >= 0; i--) {
        //         tmp += arr[i];
        //         if (tmp == target) {
        //             res++;
        //         }
        //     }
        //     arr[p] = node.val;
        //     console.log( arr, res)
        //     res += recursionPathSum(node.left, arr, target, p + 1);
        //     res += recursionPathSum(node.right, arr, target, p + 1);
        //     return res;
        // }
        var pathSum = function (root, sum) {
            return recursionPathSum(root,[0],sum,0);
        };
        function recursionPathSum(node, arr, target,p){
            if(node == null){
                return 0;
            }
            let res = 0;
            let currSum = arr[p];
            arr[p+1] = (currSum +=node.val);
            for(let i=0;i<=p;i++){
                if(arr[i] === currSum-target ){
                    res++;
                }
            }
            // console.log(arr,res,p)
            res += recursionPathSum(node.left,arr,target,p+1);
            res += recursionPathSum(node.right,arr,target,p+1);
            return res;
        }
        console.log(pathSum(tree, 0))
    </script> -->
    <h1>572另一个树的子树</h1>0304
    <!-- <script>
        let s = {
            val:3,
            left:{
                val:4,
                left:{
                    val:1
                }
            },
            right:{
                val:5,
                left:{
                    val:2
                }
            }
        }
        let t = {
            val:3,
            left:{
                val:1
            },
            right:{
                val:2,
                
            }
        }
        // let s={
        //     val:1,
        //     left:{
        //         val:1
        //     }
        // }
        // let t = {
        //     val:1
        // }
        var isSubtree = function (s, t) {
            // console.log(s,t)
            if(s!=null){
                return (s.val === t.val && equal(s,t)) || isSubtree(s.left,t) || isSubtree(s.right,t)
            }
            return false;
        };
        function equal(s,t){
            if(s != null && t != null){
                if(s.val === t.val){
                    if(equal(s.left,t.left) && equal(s.right,t.right)){
                        return true;
                    }
                }else{
                    return false;
                }
            }else if(s != null){
                return false;
            }else if(t !=null){
                return false;
            }else{
                return true;
            }
        }
        console.log(isSubtree(s,t))
    </script> -->
    <h1>101对称二叉树</h1>0304
    <script>
        let tree = {
            val: 1,
            left: {
                val: 2
            },
            right: {
                val: 2
            }
        }
        var isSymmetric = function (root) {

        };
    </script>
    <h1>111</h1>0305
    <script>

    </script>
    <h1>404</h1>0305
    <script>

    </script>
    <h1>687</h1>0306
    <script>

    </script>
    <h1>337</h1>0306
    <script>

    </script>
    <h1>671</h1>0307
    <script>

    </script>
    <h1>637</h1>六20200307
    <script>

    </script>

</body>

</html>