<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BST</title>
</head>

<body>
    <h1>669修剪二叉搜索树</h1>20200310
    <!-- <script>
        let tree = {
            val: 3,
            left: {
                val: 0,
                left: {
                    val: 2,
                    left: {
                        val: 1
                    }
                },
                right: {
                    val: 1
                }
            },
            right: {
                val: 4
            }
        };
        // 不是很明白为什么是这么个修剪规则
        var trimBST = function (root, L, R) {
            if(root == null) return null;
            if(root.val < L) return trimBST(root.right,L,R);
            if(root.val > R) return trimBST(root.left,L,R);
            root.left = trimBST(root.left,L,R);
            root.right = trimBST(root.right,L,R);
            return root;
        };
        console.log(trimBST(tree, 1, 3))

    </script> -->
    <h1>230 二叉搜索树中第K小的元素</h1>20200310
    <!-- <script>
        let tree = {
            val: 3,
            left: {
                val: 1,
                right: {
                    val: 2
                }
            },
            right: {
                val: 4
            }
        };
        var kthSmallest = function (root, k) {
            if (root == null) {
                return null;
            }
            let stack = [];
            let cur = root;
            while (true) {
                while (cur != null) {
                    stack.push(cur);
                    cur = cur.left;
                }
                // console.log(stack)
                let node = stack.pop();
                // console.log(node)
                if (--k == 0) return node.val;
                cur = node.right;
            }
        };
        console.log(kthSmallest(tree, 1))
    </script> -->
    <h1>538把二叉搜索树转换为累加树</h1>20200311
    <!-- <script>
        let tree = {
            val: 5,
            left: {
                val: 2
            },
            right: {
                val: 13
            }
        };
        // 盲写成功
        var convertBST = function (root) {
            if (root == null) return null;
            let stack = [];
            let num = 0;
            let cur = root;
            while (stack.length !== 0 || cur != null) {
                while (cur != null) {
                    stack.push(cur);
                    cur = cur.right;
                }
                let node = stack.pop();
                num += node.val;
                node.val = num;
                // console.log(node)
                if (node.left) cur = node.left;
            }
            return root;
        };
        console.log(convertBST(tree));

    </script> -->
    <h1>235二叉搜索树的最近公共祖先</h1>20200311
    <!-- <script>
        var lowestCommonAncestor = function (root, p, q) {
            if(root == null) return null;
            let node = root;
            while(node != null){
                let pval = p.val;
                let qval = q.val;
                if(node.val > pval && node.val > qval){
                    node = node.left;
                }else if(node.val < pval && node.val < qval){
                    node = node.right;
                }else{
                    return node;
                }
            }
        };
    </script> -->
    <h1>236 二叉树的最近公共祖先 二叉树的最近公共祖先</h1>20200312
    <!-- <script>
        var lowestCommonAncestor = function (root, p, q) {
            if (root == null || root == p || root == q) return root;
            console.log(root)
            let left = lowestCommonAncestor(root.left, p, q);
            let right = lowestCommonAncestor(root.right, p, q);
            return left == null ? right : right == null ? left : root;

            // if (left !== null) {
            //     if (right !== null) {
            //         return root;
            //     } else {
            //         return left;
            //     }
            // } else {
            //     return right;
            // }
        }; 
    </script> -->
    <h1>108将有序数组转换为二叉搜索树</h1>20200312
    <!-- <script>
        function TreeNode(val) {
            this.val = val;
            this.left = this.right = null;
        }
        var sortedArrayToBST = function (nums) {
            return toTreenode(nums, 0, nums.length - 1)
        };
        function toTreenode(nums, start, end) {
            if(start > end) return null;
            let m = parseInt((start + end)/2);
            let root = new TreeNode(nums[m]);
            root.left = toTreenode(nums,start,m-1);
            root.right = toTreenode(nums,m+1,end);
            console.log(root)
            return root;
        }
        console.log(sortedArrayToBST([-10, -3, 0, 5, 9]))
    </script> -->
    <h1 style="color: tomato;">109有序链表转换二叉搜索树</h1>无单链表基础，搁置20200313
    <script>
        function TreeNode(val) {
            this.val = val;
            this.left = this.right = null;
        }
        function ListNode(val) {
            this.val = val;
            this.next = null;
        }
        var sortedListToBST = function (head) {

        };

    </script>
    <h1>653两数之和 IV - 输入 BST</h1>20200313
    <script>

    </script>
    <h1>530</h1>20200314
    <script>

    </script>
    <h1>501</h1>20200314
    <script>

    </script>
    <h1>208</h1>20200315
    <script>

    </script>
    <h1>677</h1>20200315
    <script>

    </script>
</body>

</html>