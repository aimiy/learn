<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BST</title>
</head>

<body>
    <h1>669修剪二叉搜索树</h1>20200310
    <!-- <script>
        let tree = {
            val: 3,
            left: {
                val: 0,
                left: {
                    val: 2,
                    left: {
                        val: 1
                    }
                },
                right: {
                    val: 1
                }
            },
            right: {
                val: 4
            }
        };
        // 不是很明白为什么是这么个修剪规则
        var trimBST = function (root, L, R) {
            if(root == null) return null;
            if(root.val < L) return trimBST(root.right,L,R);
            if(root.val > R) return trimBST(root.left,L,R);
            root.left = trimBST(root.left,L,R);
            root.right = trimBST(root.right,L,R);
            return root;
        };
        console.log(trimBST(tree, 1, 3))

    </script> -->
    <h1>230 二叉搜索树中第K小的元素</h1>20200310
    <!-- <script>
        let tree = {
            val: 3,
            left: {
                val: 1,
                right: {
                    val: 2
                }
            },
            right: {
                val: 4
            }
        };
        var kthSmallest = function (root, k) {
            if (root == null) {
                return null;
            }
            let stack = [];
            let cur = root;
            while (true) {
                while (cur != null) {
                    stack.push(cur);
                    cur = cur.left;
                }
                // console.log(stack)
                let node = stack.pop();
                // console.log(node)
                if (--k == 0) return node.val;
                cur = node.right;
            }
        };
        console.log(kthSmallest(tree, 1))
    </script> -->
    <h1>538把二叉搜索树转换为累加树</h1>20200311
    <!-- <script>
        let tree = {
            val: 5,
            left: {
                val: 2
            },
            right: {
                val: 13
            }
        };
        // 盲写成功
        var convertBST = function (root) {
            if (root == null) return null;
            let stack = [];
            let num = 0;
            let cur = root;
            while (stack.length !== 0 || cur != null) {
                while (cur != null) {
                    stack.push(cur);
                    cur = cur.right;
                }
                let node = stack.pop();
                num += node.val;
                node.val = num;
                // console.log(node)
                if (node.left) cur = node.left;
            }
            return root;
        };
        console.log(convertBST(tree));

    </script> -->
    <h1>235二叉搜索树的最近公共祖先</h1>20200311
    <!-- <script>
        var lowestCommonAncestor = function (root, p, q) {
            if(root == null) return null;
            let node = root;
            while(node != null){
                let pval = p.val;
                let qval = q.val;
                if(node.val > pval && node.val > qval){
                    node = node.left;
                }else if(node.val < pval && node.val < qval){
                    node = node.right;
                }else{
                    return node;
                }
            }
        };
    </script> -->
    <h1>236 二叉树的最近公共祖先 二叉树的最近公共祖先</h1>20200312
    <script>

    </script>
    <h1>108</h1>20200312
    <script>

    </script>
    <h1>109</h1>20200313
    <script>

    </script>
    <h1>653</h1>20200313
    <script>

    </script>
    <h1>530</h1>20200314
    <script>

    </script>
    <h1>501</h1>20200314
    <script>

    </script>
    <h1>208</h1>20200315
    <script>

    </script>
    <h1>677</h1>20200315
    <script>

    </script>
</body>

</html>